...尾调用优化只有在【严格模式"use strict"】才生效；
...尾调用：我们知道，函数调用会在内存形成一个“调用记录”，又称“调用帧”，保存调用位置和内部变量等信息。
.......... 如果在函数A的内部调用B，那么B就在A的调用帧上方，此时就是开了两帧，【直到函数的return语句（默认执行）之后】，才会清除，
.......... 特别是在【递归】中，会无限的开启“调用帧”，造成“栈溢出”。
...所以，需要进行优化的地方，就是把内部函数【放到 return 语句后面】进行调用，
...这样的好处就是，每次都会先关闭一个“调用帧”，再开启下一个“调用帧”。

   function add(a){
      var one = 1;
      function inner(b){
         return b + one;
      }
      return inner(a);	//由于这里使用内部的inner函数，所以不会进行尾优化
   }

--->【递归尾优化】
   function reduce(n = 0, step = 1){   //使用默认值，就不需要在函数内部声明默认值了
      if(n <= 0){
         return 0;
      }
      console.log(n);
      return reduce(n-step, step);   //直接继承参数，没有使用到内部变量
   }

