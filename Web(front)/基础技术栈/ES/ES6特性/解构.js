//================================§基本特征§========================================

//...事实上，只要某种数据结构具有iterator接口，都可以进行解构
var [a,b] = ["a", "b"];	//a = "a",b = "b"
var [a,b] = {a: "a", b: "b"};	//a = "a",b = "b";

//...【解构别名】：
//...前面的foo，代表需要解构的对象的属性名，_foo，代表需要创建的变量名（存储器名）
var {foo:_foo} = {foo: "bar"};	//_foo = "bar"；

//...【解构字符串】：
var [a,b,c,d,e] = "hello";	//a="h",b="e"....
var {length:len} = "hello";	//len = 5; （这时候"hello"，就被当成一个对象进行解构，默认有一个属性length;）

//...【特殊用法】：
var [x,y,...z] = [1, 2, 3, 4, 5];	//z = [3,4,5]

//...【关于默认值】：
//...解构时可以设置默认值,【默认值生效的条件是：被解构的对象的值必须严格等于undefined】
var {b=1} = {a: "b"};	//b = 1;
var {b=1} = {b: "b"};	//b = "b";


//...如果默认值使用的是函数：
//...那么这个函数的表达式将是一个惰性求值,所谓惰性求值，就是，只有在解构的对象的值为undefined的时候，才取函数返回的值
var [x = f()] = [1];	//x = 1;
var [x = f()] = [undefined];	//x = f();

//...【需要注意的地方】：
//...如果需要给以声明的变量进行解构赋值，必须要清楚一点：
//    var x;
//    {x} = {x:1};	//syntax err;

//...以上代码第二行，被js引擎解析成了一个代码块，所以需要改写成：
var x;
({x} = {x: 1});	//x = 1;


//================================§适用场景§========================================

//...【使用场景1】：可以让代码更加直观，不用再在回调里工作
var getstate = () => {
    return {error: false, status: true, data: ""};
};
var {err,state,data} = getstate();


//...【使用场景2】：可以直接获取某个对象里面的方法
let {floor} = Math;
floor(3.1415926);	//3

//...【使用场景3】：对函数的传递进来的实参进行解构
[[1, 2], [3, 4]].map(([a,b])=>a + b);	//[3,7]
function foo({x,y} = {x: 0, y: 0}) {
}	//这里只是对参数进行默认值设置，而非对x,y两个变量进行设置，需要注意

//...【使用场景4】：交换数组元素的位置，（冒泡排序？）
[x,y] = [y, x];

//...【使用场景5】：快速提取json
var json = {y: "", x: 0, z: []};
var {x:a,y:b,z:[...c]} = json;

//...【使用场景6】: 为参数设置默认值
function action({
    async = true,
    url = "http://www.baidu.com",
    callback = function () {
    }
    }
) {
    console.log(async,url,callback);
}