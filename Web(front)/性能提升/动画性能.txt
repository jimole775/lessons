
1,渲染机制：
	根据60帧/秒的渲染机制，那么每一帧的渲染时间就只有16.67ms，实际上，浏览器内核自身支撑体系运行也需要消耗一些时间，所以留给我们的时间差不多只有10ms。

2,掉帧分析：
	Timeline下面勾选JSProfile和Paint,点击录制按钮，然后操作，操作完毕之后，点击stop,选中捕获的帧片段，然后就可以在summary选项下面进行详细的分析了。

4，拆分代码片段：
	一般情况下，如果js函数调用时间比较长，可以把一个函数拆分成多个任务执行；
	方法如下，
	1）.首先，创建一个Task类，
		function Task(){
			this.tasks = [];
		}
		Task.prototype.addTask = function(){
			this.tasks.push(task);
		}

		Task.prototype.draw = function(){
			var that = this;
			window.requestAnimationFrame(function(){
				var tasks = that.tasks;
				if(tasks.length){
				  var task = tasks.shift();
				  task();
				}
				//这里需要思考一个问题，由于requestAnimationFrame是一个全局对象，每次new一个Task，进行draw的时候，
				//会把上一个传给它的task给覆盖掉（意思就是每次的对象实例都是同一个对象名）
				window.requestAnimationFrame(function(){that.draw.call(that)});

			});

		};

	2).然后，封装一个mapTask的单例，存放在map页面的task;
		var aTask = null;
		var mapTask = {
		  get:function(){
		    if(!aTask){
		      aTask = new Task();
		      aTask.draw();
		    }
		    return aTask;
		  },
		  add:function(task){
		    mapTask.get().addTask(task);
		  }
		};
	3).需要插入一个任务时就调用以下mapTask.add,把耗时的函数分别当作单例任务插进队列，
	   教程文档的实例（关于地图应用的）：
		updateHouses:function(houses){
		  var remainMultipleMarkers = null;
		  var housesFilter = null;
		      housesFilter = filterData.filterHouse(houses);
		  remainMultipleMarkers = filterData.removeOldHouses(housesFilter.remainsHouses);
		  housesFilter.newHouses = housesFilter.newHouses.concat(remainMultipleMarkers);
		  filterData.addNewHouses(housesFilter.newHouses);
		}

	   现在把上面的函数改成两个task，并加到任务队列里面；
		mapTask.add(function(){
		  housesFilter = filterData.filterHouse(houses);
		  remainMultipleMarkers = filterData.removeOldHouses(housesfilter.remainsHouses);
		})
		mapTask.add(function(){
		  housesFilter.newHouses = housesFilter.newHouses.concat(remainMultipleMarkers);
		  filterData.addNewHouses(housesFilter.newHouses);
		})
	
