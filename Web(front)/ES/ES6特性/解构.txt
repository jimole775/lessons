
================================§基本特征§========================================

...事实上，只要某种数据结构具有iterator接口，都可以进行解构
    var [a,b] = ["a","b"];	//a = "a",b = "b"
    var [a,b] = {a:"a",b:"b"};	//a = "a",b = "b";

...【解构别名】：
...前面的foo，代表需要解构的对象的属性名，_foo，代表需要创建的变量名（存储器名）
    var {foo:_foo} = {foo:"bar"}	//_foo = "bar"；

...【解构字符串】：
    var [a,b,c,d,e] = "hello";	//a="h",b="e"....
    var {length:len} = "hello";	//len = 5; （这时候"hello"，就被当成一个对象进行解构，默认有一个属性length;）

...【特殊用法】：
    var [x,y,...z] = [1,2,3,4,5];	//z = [3,4,5]

...【关于默认值】：
...解构时可以设置默认值,【默认值生效的条件是：被解构的对象的值必须严格等于undefined】
    var {b=1} = {a:"b"}	//b = 1;
    var {b=1} = {b:"b"}	//b = "b";


...如果默认值使用的是函数：
...那么这个函数的表达式将是一个惰性求值,所谓惰性求值，就是，只有在解构的对象的值为undefined的时候，才取函数返回的值
    var [x = f()] = [1];	//x = 1;
    var [x = f()] = [undefined];	//x = f();

...【需要注意的地方】：
...如果需要给以声明的变量进行解构赋值，必须要清楚一点：
    var x;
    {x} = {x:1};	//syntax err;

...以上代码第二行，被js引擎解析成了一个代码块，所以需要改写成：
    var x;
    ({x} = {x:1});	//x = 1;


================================§适用场景§========================================

...【使用场景1】：可以让代码更加直观，不用再在回调里工作
    var getstate = （）=> {return {error:false,status:true,data:""}}
    var {err,stste,data} = getstate();
    if(err)return;

...【使用场景2】：可以直接获取某个对象里面的方法
    let {floor} = Math;
    floor(3.1415926);	//3

...【使用场景3】：对函数的传递进来的实参进行解构
    [[1,2],[3,4]].map(([a,b])=>a+b)	//[3,7]
    function foo({x,y} = {x:0,y:0}){}	//这里只是对参数进行默认值设置，而非对x,y两个变量进行设置，需要注意

...【使用场景4】：交换数组元素的位置，（冒泡排序？）
    [x,y] = [y,x]

...【使用场景5】：快速提取json
    var json = {y:"",x:0,z:[]};
    var {x:a,y:b,z:[...c]} = json;

...【使用场景6】: 为参数设置默认值
    function action({
    	async=true,
    	url="http://www.baidu.com",
    	callback=function(){}
    	}){
    }